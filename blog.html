<!doctype html>
<html>
<head>
</head>
<head>
	<meta charset="UTF-8">
	<title>Special syntax for language features: rationale</title>
</head>
<body>
<h2>Special syntax for language features: rationale</h2>

<p>Date of posting: 26'th january of 2023.</p>

<p>(This is a distinction I saw many languages making, but just today I understood what it really brings to the table.)</p>

<p>Assume you want to introduce async/await semantics in a new version of your language. Should syntax for awaiting look like a regular function call? I argue that it shouldn't. To show why, let's go through a thought experiment and see where it leads us.</p>

<p>Assume awaiting looks the following way: <code>await foo</code>; function calls look like this: <code>foo(arg)</code>.</p>

<p>You had previous versions of the language.</p>

<p>A user of the previous version of the language used the name <code>await</code> in their code to name a function. They use it and the call looks like this: <code>await(34)</code>. Of course, they didn't know about your great plans to introduce async/await and they used the name <code>await</code> in a semantically different way from how your new feature works.</p>

<p>What is the benefit of having <code>await</code> feature not work like a function?</p>

<p>The benefit is this: when a user decides to switch to a new version of the language with the <code>await</code> feature, dependending on implementation, two possible things will happen with their old code:</p>

<p>1) the language implementation will reject the old code (<code>await(foo)</code>), precisely because your new syntax doesn't look like functions, forcing the user to rename their old function;</p>

<p>2) or, the langauge implementation will detect that new langauge syntax is orthogonal to function calls and pass the old code through, not changing the meaning of user's program.</p>

<p>But, if usage of <code>await</code> looked like a regular function call, user's code will suddenly be riddled with mysterious bugs.</p>

<p>So, to prevent breakage, consider making your language's features look syntactically different from regular functions.</p>

<p>Credit: thought came about while watching a talk by Ian Lance Taylor about backwards compatibility: <a href="https://www.youtube.com/watch?v=LqKOY_pH8u0">"Transition to Go 2"</a>.</p>

</body>
</html>
