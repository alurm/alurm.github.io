<!doctype html>
<html>
<head>
</head>
<head>
	<meta charset="UTF-8">
	<title>Special syntax for language features: rationale</title>
</head>
<body>
<h2>Special syntax for language features: rationale</h2>

<p>Date of posting: 26th january of 2023.</p>

<p>Author: Alan Urmancheev.</p>

<p>(This is a distinction I saw many languages making, but just today I understood what it really brings to the table.)</p>

<p>Assume you want to introduce async/await semantics in a new version of your language. Should syntax for awaiting look like a regular function call? I argue that it shouldn't. To show why, let's go through a thought experiment and see where it leads us.</p>

<p>Assume awaiting looks the following way: <code>await foo</code>; function calls look like this: <code>foo(arg)</code>.</p>

<p>You had previous versions of the language.</p>

<p>A user of a previous version of the language used the name <code>await</code> in their code to name a function. They use it and the call looks like this: <code>await(34)</code>. Of course, they didn't know about your great plans to introduce async/await and they used the name <code>await</code> in a semantically different way from how your new feature works.</p>

<p>What is the benefit of having <code>await</code> feature not work like a function?</p>

<p>The benefit is this: when a user decides to switch to a new version of the language with the <code>await</code> feature, given appropriate language specification and implementation, it's possible to keep old user's code working without any changes. Because language features don't look like function calls, it's possible to differentiate between the two. One can think that language keywords and function names live  in separate namespaces.</p>

<p>At the very least, user's old code will be rejected by the language  implementation, forcing the user to pick a new name for a function.</p>

<p>But if usage of <code>await</code> looked like a regular function call, user's code might suddenly be riddled with mysterious bugs.</p>

<p>So, to prevent breakage, consider making your language's features look syntactically different from regular functions.</p>

<p>Credit: thought came about while watching a talk by Ian Lance Taylor about backwards compatibility: <a href="https://www.youtube.com/watch?v=LqKOY_pH8u0">"Transition to Go 2"</a>.</p>

</body>
</html>
